{"version":3,"sources":["cluster.ts","clusters.ts","explorer-rock-properties-components.min.js","zoom.ts"],"names":["rpComponents","rpComponents.cluster","rpComponents.cluster.Cluster","rpComponents.cluster.Cluster.constructor","rpComponents.clusterService","rpComponents.clusterService.ClusterService","rpComponents.clusterService.ClusterService.constructor","rpComponents.clusterService.ClusterService.init","rpComponents.clusterService.ClusterService.toggleClusters","rpComponents.clusterService.ClusterService.getClusters","rpComponents.clusterService.ClusterService.getClusterInfo","rpComponents.clusterService.ClusterService.drawClusters","rpComponents.clusterService.ClusterService.buildSphereInstance","rpComponents.clusterService.ClusterService.buildLabel","rpComponents.clusterService.ClusterService.computeClusterAttributes","rpComponents.zoom","rpComponents.zoom.ZoomLevelService","rpComponents.zoom.ZoomLevelService.constructor","rpComponents.zoom.ZoomLevelService.getIndex","rpComponents.zoom.ZoomLevelService.setActive","rpComponents.zoom.ZoomLevelService.getViewExtent"],"mappings":"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","file":"explorer-rock-properties-components.min.js","sourcesContent":["/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n *\n *   Initial shell for single cluster\n *\n */\nmodule rpComponents.cluster {\n\n    'use strict';\n\n    /**\n     *\n     * Each of the properties contains an aggregated data summary, e.g.\n     *\n     * property: {\n     *  \"magnetic susceptibility\": 79.8,\n     *  \"total porosity\": 18.2,\n     *  \"grain mass density\": 2\n     * }\n     *\n     *\n     *\n     */\n    export interface ICluster {\n        count: number,\n        lat: number,\n        lon: number,\n        elev: number,\n        lithologyGroup: {},\n        property: {},\n        provinceName: {},\n        sampleType: {},\n        stratigraphicUnitName: {},\n    }\n\n    export class Cluster implements ICluster{\n\n        static $inject = [\n            \"count\",\n            \"lat\",\n            \"lon\",\n            \"elev\",\n            \"lithologyGroup\",\n            \"property\",\n            \"provinceName\",\n            \"sampleType\",\n            \"stratigraphicUnitName\"\n        ];\n\n        constructor(\n            public count: number,\n            public lat: number,\n            public lon: number,\n            public elev: number,\n            public lithologyGroup: {},\n            public property: {},\n            public provinceName: {},\n            public sampleType: {},\n            public stratigraphicUnitName: {}\n        ) {}\n    }\n\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\ndeclare var Cesium: any;\n\nmodule rpComponents.clusterService {\n\n    'use strict';\n\n    export interface IClusterService {\n\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        toggleClusters(): void;\n        getClusters(heightIndex: number, extent: any): [rpComponents.cluster.ICluster];\n        reCluster(): void;\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any;\n        buildLabel(cluster: rpComponents.cluster.ICluster): any;\n        drawClusters(sphereInstances: any, labelCollection: any): void;\n    }\n\n    export class ClusterService implements IClusterService {\n\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        static $inject = [\n            \"$http\",\n            \"$rootScope\",\n            \"zoomLevelService\"\n        ];\n\n        constructor(\n            public $http: ng.IHttpService,\n            public $rootScope: ng.IRootScopeService,\n            public zoomLevelService: rpComponents.zoom.IZoomLevelService\n        ) {\n\n        }\n\n        init(viewer: any, serviceUrl: string): void {\n\n            this.viewer = viewer;\n            this.zoomLevelService.viewer = viewer;\n            this.serviceUrl = serviceUrl;\n\n            this.$rootScope.$on('rocks.clusters.update', () => {\n                this.reCluster();\n            });\n        }\n\n        toggleClusters(): void {\n\n            if(this.clustersCollection){\n\n                this.clustersCollection.show = !this.clustersCollection.show;\n                this.zoomLevelService.setActive(this.clustersCollection.show);\n                this.reCluster();\n            }\n\n            // init clusters\n            else {\n                this.clustersCollection = new Cesium.PrimitiveCollection();\n                this.viewer.scene.primitives.add(this.clustersCollection);\n\n                this.zoomLevelService.setActive(true);\n                this.reCluster();\n\n                var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n                handler.setInputAction((movement: any) => {\n                    var pick = this.viewer.scene.pick(movement.position);\n\n                    //if (Cesium.defined(pick) && (pick.id === 'hello id')) {\n                    if (Cesium.defined(pick)) {\n                        console.log('id: ');\n                        console.log(pick.id);\n                    }\n                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n            }\n        }\n\n        /**\n         *\n         * This will be extended to use extent + zoom/index and filters on cluster service\n         * TODO where will we get our extent - shouldn't depend on minimap\n         * TODO filters\n         *\n         * @returns {IHttpPromise<T>}\n         */\n        public getClusters(): any {\n\n            // debug\n            return this.$http({\n                method: 'GET',\n                url: this.serviceUrl + this.zoomLevelService.nextIndex + '.json',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: {\n                    heightIndex: this.zoomLevelService.nextIndex,\n                    extent: this.zoomLevelService.getViewExtent(100)\n                }\n            });\n        }\n\n        /**\n         *\n         *\n         *\n         * @param cluster\n         */\n        public getClusterInfo(cluster: rpComponents.cluster.ICluster): any {\n            console.log(\"TODO query service for cluster info for:\");\n            console.log(cluster);\n        }\n\n        /**\n         *\n         * We get a performance benefit when we use fewer primitives/collections to draw multiple static geometries.\n         *\n         */\n        reCluster = (): void => {\n\n            var sphereInstances: any = [];\n            var labelCollection: any = new Cesium.LabelCollection();\n\n            this.getClusters().then((response: any) => {\n\n                if(response.data){\n\n                    var clusters: [rpComponents.cluster.ICluster] = response.data;\n\n                    for(var i = 0; i < clusters.length; i++){\n                        sphereInstances.push(this.buildSphereInstance(clusters[i]));\n                        labelCollection.add(this.buildLabel(clusters[i]));\n                    }\n\n                    this.drawClusters(sphereInstances, labelCollection);\n                }\n                else {\n                    console.log(\"got no clusters\");\n                }\n            });\n        }\n\n\n        drawClusters(sphereInstances: any, labelCollection: any): void {\n\n            this.clustersCollection.removeAll();\n            this.clustersCollection.add(new Cesium.Primitive({\n                geometryInstances : sphereInstances,\n                appearance : new Cesium.PerInstanceColorAppearance({\n                    translucent : true,\n                    closed : true\n                })\n            }));\n\n            this.clustersCollection.add(labelCollection);\n        }\n\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            // Sphere geometries are initially centered on the origin.\n            // We can use a model matrix to position the sphere on the globe surface.\n            var positionOnEllipsoid = Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat);\n            var modelMatrix = Cesium.Matrix4.multiplyByTranslation(\n                Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid),\n                new Cesium.Cartesian3(cluster.lon, cluster.lat, clusterProps.size), new Cesium.Matrix4()\n            );\n            // Create a sphere geometry.\n            var sphereGeometry = new Cesium.SphereGeometry({\n                vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,\n                radius : clusterProps.size\n            });\n\n            // Create a geometry instance using the geometry and model matrix created above.\n            var sphereInstance = new Cesium.GeometryInstance({\n                geometry : sphereGeometry,\n                modelMatrix : modelMatrix,\n                vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,\n                attributes : {\n                    color : Cesium.ColorGeometryInstanceAttribute.fromColor(clusterProps.color)\n                },\n                id: cluster // for picking\n            });\n\n            return sphereInstance;\n        }\n\n        buildLabel(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            return {\n                position : Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat, 20 + (clusterProps.size * 2)),\n                text: cluster.count.toString(),\n                fillColor: Cesium.Color.BLACK,\n                outlineColor: Cesium.Color.RED,\n                font: '30px arial, sans-serif',\n                horizontalOrigin: Cesium.HorizontalOrigin.CENTER//,\n            };\n        }\n\n        computeClusterAttributes(count: number): any {\n\n            if(count < 10){\n                 return {size: 10000 * this.zoomLevelService.nextIndex, color: Cesium.Color.fromCssColorString('#4781cd').withAlpha(0.5) };\n            }\n            else if(count >= 10 && count < 1000){\n                return {size: 10000  * this.zoomLevelService.nextIndex, color: Cesium.Color.fromCssColorString('#0fc70e').withAlpha(0.5) };\n            }\n            else {\n                return {size: 10000  * this.zoomLevelService.nextIndex, color: Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.5) };\n            }\n        }\n    }\n\n    // ng register\n    angular\n        .module('explorer.rockproperties.clusters', [])\n        .factory(\"clusterService\", [\"$http\", \"$rootScope\", \"zoomLevelService\",\n            ($http: ng.IHttpService, $rootScope: ng.IRootScopeService, zoomLevelService: rpComponents.zoom.IZoomLevelService) =>\n                new rpComponents.clusterService.ClusterService($http, $rootScope, zoomLevelService)]);\n\n}\n","var rpComponents;!function(e){var t;!function(e){\"use strict\";var t=function(){function e(e,t,o,i,r,s,n,l,c){this.count=e,this.lat=t,this.lon=o,this.elev=i,this.lithologyGroup=r,this.property=s,this.provinceName=n,this.sampleType=l,this.stratigraphicUnitName=c}return e.$inject=[\"count\",\"lat\",\"lon\",\"elev\",\"lithologyGroup\",\"property\",\"provinceName\",\"sampleType\",\"stratigraphicUnitName\"],e}();e.Cluster=t}(t=e.cluster||(e.cluster={}))}(rpComponents||(rpComponents={}));var rpComponents;!function(e){var t;!function(t){\"use strict\";var o=function(){function e(e,t,o){var i=this;this.$http=e,this.$rootScope=t,this.zoomLevelService=o,this.reCluster=function(){var e=[],t=new Cesium.LabelCollection;i.getClusters().then(function(o){if(o.data){for(var r=o.data,s=0;s<r.length;s++)e.push(i.buildSphereInstance(r[s])),t.add(i.buildLabel(r[s]));i.drawClusters(e,t)}else console.log(\"got no clusters\")})}}return e.prototype.init=function(e,t){var o=this;this.viewer=e,this.zoomLevelService.viewer=e,this.serviceUrl=t,this.$rootScope.$on(\"rocks.clusters.update\",function(){o.reCluster()})},e.prototype.toggleClusters=function(){var e=this;if(this.clustersCollection)this.clustersCollection.show=!this.clustersCollection.show,this.zoomLevelService.setActive(this.clustersCollection.show),this.reCluster();else{this.clustersCollection=new Cesium.PrimitiveCollection,this.viewer.scene.primitives.add(this.clustersCollection),this.zoomLevelService.setActive(!0),this.reCluster();var t=new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);t.setInputAction(function(t){var o=e.viewer.scene.pick(t.position);Cesium.defined(o)&&(console.log(\"id: \"),console.log(o.id))},Cesium.ScreenSpaceEventType.LEFT_CLICK)}},e.prototype.getClusters=function(){return this.$http({method:\"GET\",url:this.serviceUrl+this.zoomLevelService.nextIndex+\".json\",headers:{\"Content-Type\":\"application/json\"},data:{heightIndex:this.zoomLevelService.nextIndex,extent:this.zoomLevelService.getViewExtent(100)}})},e.prototype.getClusterInfo=function(e){console.log(\"TODO query service for cluster info for:\"),console.log(e)},e.prototype.drawClusters=function(e,t){this.clustersCollection.removeAll(),this.clustersCollection.add(new Cesium.Primitive({geometryInstances:e,appearance:new Cesium.PerInstanceColorAppearance({translucent:!0,closed:!0})})),this.clustersCollection.add(t)},e.prototype.buildSphereInstance=function(e){var t=this.computeClusterAttributes(e.count),o=Cesium.Cartesian3.fromDegrees(e.lon,e.lat),i=Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(o),new Cesium.Cartesian3(e.lon,e.lat,t.size),new Cesium.Matrix4),r=new Cesium.SphereGeometry({vertexFormat:Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,radius:t.size}),s=new Cesium.GeometryInstance({geometry:r,modelMatrix:i,vertexFormat:Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(t.color)},id:e});return s},e.prototype.buildLabel=function(e){var t=this.computeClusterAttributes(e.count);return{position:Cesium.Cartesian3.fromDegrees(e.lon,e.lat,20+2*t.size),text:e.count.toString(),fillColor:Cesium.Color.BLACK,outlineColor:Cesium.Color.RED,font:\"30px arial, sans-serif\",horizontalOrigin:Cesium.HorizontalOrigin.CENTER}},e.prototype.computeClusterAttributes=function(e){return 10>e?{size:1e4*this.zoomLevelService.nextIndex,color:Cesium.Color.fromCssColorString(\"#4781cd\").withAlpha(.5)}:e>=10&&1e3>e?{size:1e4*this.zoomLevelService.nextIndex,color:Cesium.Color.fromCssColorString(\"#0fc70e\").withAlpha(.5)}:{size:1e4*this.zoomLevelService.nextIndex,color:Cesium.Color.fromCssColorString(\"#ff0000\").withAlpha(.5)}},e.$inject=[\"$http\",\"$rootScope\",\"zoomLevelService\"],e}();t.ClusterService=o,angular.module(\"explorer.rockproperties.clusters\",[]).factory(\"clusterService\",[\"$http\",\"$rootScope\",\"zoomLevelService\",function(t,o,i){return new e.clusterService.ClusterService(t,o,i)}])}(t=e.clusterService||(e.clusterService={}))}(rpComponents||(rpComponents={}));var rpComponents;!function(e){var t;!function(t){\"use strict\";var o=function(){function e(e){var t=this;this.$rootScope=e,this.zoomLevels=[5e3,1e4,2e4,4e4,75e4,15e5,25e5,35e5,55e5,65e5,8e6],this.defaultExtent={west:109,south:-45,east:158,north:-8},this.moveEndHandler=function(){t.nextIndex=t.getIndex(Cesium.Ellipsoid.WGS84.cartesianToCartographic(t.viewer.camera.position).height),t.previousIndex>-1&&t.previousIndex!=t.nextIndex&&t.$rootScope.$broadcast(\"rocks.clusters.update\",t.nextIndex),t.previousIndex=t.nextIndex}}return e.prototype.getIndex=function(e){for(var t=0;t<this.zoomLevels.length;t++)if(e<this.zoomLevels[t])return t;return this.zoomLevels.length-1},e.prototype.setActive=function(e){e?(this.previousIndex=this.getIndex(Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.viewer.camera.position).height),this.nextIndex=this.previousIndex,this.viewer.camera.moveEnd.addEventListener(this.moveEndHandler)):this.viewer.camera.moveEnd.removeEventListener(this.moveEndHandler)},e.prototype.getViewExtent=function(e){var t=Cesium.Ellipsoid.WGS84,o=window.devicePixelRatio||1,i=new Cesium.Cartesian2(-e,-e),r=this.viewer.scene.camera.pickEllipsoid(i,t);i=new Cesium.Cartesian2(this.viewer.scene.canvas.width/o+e,this.viewer.scene.canvas.height/o+e);var s=this.viewer.scene.camera.pickEllipsoid(i,t);return null!=r&&null!=s?(r=t.cartesianToCartographic(r),s=t.cartesianToCartographic(s),r.longitude>s.longitude?this.defaultExtent:{west:Cesium.Math.toDegrees(r.longitude),south:Cesium.Math.toDegrees(s.latitude),east:Cesium.Math.toDegrees(s.longitude),north:Cesium.Math.toDegrees(r.latitude)}):this.defaultExtent},e.$inject=[\"$rootScope\"],e}();t.ZoomLevelService=o,angular.module(\"explorer.rockproperties.zoom\",[]).factory(\"zoomLevelService\",[\"$rootScope\",function(t){return new e.zoom.ZoomLevelService(t)}])}(t=e.zoom||(e.zoom={}))}(rpComponents||(rpComponents={}));\n//# sourceMappingURL=explorer-rock-properties-components.min.js.map\n","/// <reference path=\"../../typings/tsd.d.ts\" />\n\ndeclare var Cesium: any;\n\n/**\n *\n * Handles the arbitrary 'zoom' levels/ranges that we will display different cluster granularities.\n *\n *\n */\nmodule rpComponents.zoom {\n\n    'use strict';\n\n    export interface IZoomLevelService {\n        viewer: any;\n        zoomLevels: any;\n        nextIndex: number;\n        previousIndex: number;\n        defaultExtent: any;\n\n        setActive(active:boolean): void;\n        moveEndHandler(): void;\n        getIndex(height: number): void;\n        getViewExtent(offset: number): any;\n    }\n\n    export class ZoomLevelService implements IZoomLevelService {\n\n        viewer: any;\n        // Arbitrary height indexes: < 5000 is 0, > 500 && < 10000 is 1 etc.\n        zoomLevels: any = [5000, 10000, 20000, 40000, 750000, 1500000, 2500000, 3500000, 5500000, 6500000, 8000000];\n        nextIndex: number;\n        previousIndex: number;\n        defaultExtent: any = {\n            \"west\": 109,\n            \"south\": -45,\n            \"east\": 158,\n            \"north\": -8\n        }\n\n        static $inject = [\n            \"$rootScope\"\n        ];\n\n        constructor(public $rootScope:ng.IRootScopeService) {\n\n        }\n\n        public moveEndHandler = () => {\n\n            this.nextIndex = this.getIndex(Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.viewer.camera.position).height);\n\n            // changed indexes, trigger recluster\n            if(this.previousIndex > -1 && this.previousIndex != this.nextIndex){\n                this.$rootScope.$broadcast('rocks.clusters.update', this.nextIndex);\n            }\n\n            this.previousIndex = this.nextIndex;\n        };\n\n        /**\n         *\n         * Get the lowest index the height fits into\n         *\n         * @param height\n         * @returns {number}\n         */\n        public getIndex(height: number){\n            for(var i = 0; i < this.zoomLevels.length; i++){\n                if(height < this.zoomLevels[i]){\n                    return i;\n                }\n            }\n            return this.zoomLevels.length - 1;\n        }\n\n        public setActive(active:boolean) {\n            if(active) {\n                // TODO extent\n                this.previousIndex = this.getIndex(Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.viewer.camera.position).height);\n                this.nextIndex = this.previousIndex;\n\n                this.viewer.camera.moveEnd.addEventListener(this.moveEndHandler);\n            }\n            else {\n                this.viewer.camera.moveEnd.removeEventListener(this.moveEndHandler);\n            }\n        }\n\n        /**\n         *\n         * WKT? GeoJSON? - leave until approach is clearer.\n         * TODO this is here temporarily, more thought needed re managing the buffered extent currently handled by minimap.\n         *\n         * @param offset\n         * @returns {any}\n         */\n        public getViewExtent(offset: number){\n\n            var ellipsoid = Cesium.Ellipsoid.WGS84;\n            var pixelRatio = window.devicePixelRatio || 1;\n\n            var c2 = new Cesium.Cartesian2(-offset, -offset);\n            var leftTop = this.viewer.scene.camera.pickEllipsoid(c2, ellipsoid);\n\n            c2 = new Cesium.Cartesian2(\n                (this.viewer.scene.canvas.width / pixelRatio) + offset,\n                (this.viewer.scene.canvas.height / pixelRatio) + offset\n            );\n\n            var rightDown = this.viewer.scene.camera.pickEllipsoid(c2, ellipsoid);\n            if(leftTop != null && rightDown != null){\n\n                leftTop = ellipsoid.cartesianToCartographic(leftTop);\n                rightDown = ellipsoid.cartesianToCartographic(rightDown);\n\n                // sometimes at a certain camera pos/zoom, the canvas corners effectively disappear over\n                // the horizon and wrap around the globe, while still passing as a valid rectangle\n                if(leftTop.longitude > rightDown.longitude){\n                    return this.defaultExtent;\n                }\n\n                return {\n                    west: Cesium.Math.toDegrees(leftTop.longitude),\n                    south: Cesium.Math.toDegrees(rightDown.latitude),\n                    east: Cesium.Math.toDegrees(rightDown.longitude),\n                    north: Cesium.Math.toDegrees(leftTop.latitude)\n                };\n            }\n\n            // The sky is visible, fallback to default\n            else {\n                return this.defaultExtent;\n            }\n        }\n\n    }\n\n    // ng register\n    angular\n        .module('explorer.rockproperties.zoom', [])\n        .factory(\"zoomLevelService\", [\"$rootScope\",\n            ($rootScope:ng.IRootScopeService) => new rpComponents.zoom.ZoomLevelService($rootScope)]);\n\n}\n"],"sourceRoot":"/source/"}