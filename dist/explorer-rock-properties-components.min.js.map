{"version":3,"sources":["cluster.ts","clusters.ts","explorer-rock-properties-components.min.js"],"names":["rpComponents","rpComponents.cluster","rpComponents.cluster.Cluster","rpComponents.cluster.Cluster.constructor","rpComponents.clusterService","rpComponents.clusterService.ClusterService","rpComponents.clusterService.ClusterService.constructor","rpComponents.clusterService.ClusterService.init","rpComponents.clusterService.ClusterService.toggleClusters","rpComponents.clusterService.ClusterService.getClusters","rpComponents.clusterService.ClusterService.addClusters","rpComponents.clusterService.ClusterService.drawClusters","rpComponents.clusterService.ClusterService.buildSphereInstance","rpComponents.clusterService.ClusterService.buildLabel","rpComponents.clusterService.ClusterService.computeClusterAttributes"],"mappings":"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","file":"explorer-rock-properties-components.min.js","sourcesContent":["/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n *\n *   Initial shell for single cluster\n *\n */\nmodule rpComponents.cluster {\n\n    'use strict';\n\n    /**\n     *\n     * Each of the properties contains an aggregated data summary, e.g.\n     *\n     * property: {\n     *  \"magnetic susceptibility\": 79.8,\n     *  \"total porosity\": 18.2,\n     *  \"grain mass density\": 2\n     * }\n     *\n     *\n     *\n     */\n    export interface ICluster {\n        count: number,\n        lat: number,\n        lon: number,\n        elev: number,\n        lithologyGroup: {},\n        property: {},\n        provinceName: {},\n        sampleType: {},\n        stratigraphicUnitName: {},\n    }\n\n    export class Cluster implements ICluster{\n\n        static $inject = [\n            \"count\",\n            \"lat\",\n            \"lon\",\n            \"elev\",\n            \"lithologyGroup\",\n            \"property\",\n            \"provinceName\",\n            \"sampleType\",\n            \"stratigraphicUnitName\"\n        ];\n\n        constructor(\n            public count: number,\n            public lat: number,\n            public lon: number,\n            public elev: number,\n            public lithologyGroup: {},\n            public property: {},\n            public provinceName: {},\n            public sampleType: {},\n            public stratigraphicUnitName: {}\n        ) {}\n    }\n\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\ndeclare var Cesium: any;\n\nmodule rpComponents.clusterService {\n\n    'use strict';\n\n    export interface IClusterService {\n\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        toggleClusters(): void;\n        getClusters(): [rpComponents.cluster.ICluster];\n        addClusters(): void;\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any;\n        buildLabel(cluster: rpComponents.cluster.ICluster): any;\n        drawClusters(sphereInstances: any, labelCollection: any): void;\n    }\n\n    export class ClusterService implements IClusterService {\n\n        http: ng.IHttpService;\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        static $inject = [\n            \"$http\",\n            \"$rootScope\"\n        ];\n\n        constructor(\n            public $http: ng.IHttpService,\n            public $rootScope: ng.IRootScopeService\n        ) {}\n\n        init(viewer: any, serviceUrl: string): void {\n            this.viewer = viewer;\n            this.serviceUrl = serviceUrl;\n        }\n\n        toggleClusters(): void {\n\n            if(this.clustersCollection){\n                this.clustersCollection.show = !this.clustersCollection.show;\n            }\n            else {\n                this.clustersCollection = new Cesium.PrimitiveCollection();\n                this.viewer.scene.primitives.add(this.clustersCollection);\n\n                this.addClusters();\n            }\n        }\n\n        /**\n         *\n         * This will be extended to use extent + zoom on cluster service\n         *\n         * @returns {IHttpPromise<T>}\n         */\n        getClusters(): any {\n            return this.$http.get(this.serviceUrl + 'clusters');\n        }\n\n        /**\n         *\n         * We get a performance benefit when we use fewer primitives/collections to draw multiple static geometries.\n         *\n         */\n        addClusters(): void {\n\n            var sphereInstances: any = [];\n            var labelCollection: any = new Cesium.LabelCollection();\n\n            this.getClusters().then((response: any) => {\n\n                if(response.data){\n\n                    var clusters: [rpComponents.cluster.ICluster] = response.data;\n\n                    for(var i = 0; i < clusters.length; i++){\n                        sphereInstances.push(this.buildSphereInstance(clusters[i]));\n                        labelCollection.add(this.buildLabel(clusters[i]));\n                    }\n\n                    this.drawClusters(sphereInstances, labelCollection);\n                }\n                else {\n                    console.log(\"got no clusters\");\n                }\n            });\n        }\n\n\n        drawClusters(sphereInstances: any, labelCollection: any): void {\n\n            this.clustersCollection.add(new Cesium.Primitive({\n                geometryInstances : sphereInstances,\n                appearance : new Cesium.PerInstanceColorAppearance({\n                    translucent : true,\n                    closed : true\n                })\n            }));\n\n            this.clustersCollection.add(labelCollection);\n        }\n\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            // Sphere geometries are initially centered on the origin.\n            // We can use a model matrix to position the sphere on the globe surface.\n            var positionOnEllipsoid = Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat);\n            var modelMatrix = Cesium.Matrix4.multiplyByTranslation(\n                Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid),\n                new Cesium.Cartesian3(cluster.lon, cluster.lat, cluster.elev + clusterProps.size), new Cesium.Matrix4()\n            );\n            // Create a sphere geometry.\n            var sphereGeometry = new Cesium.SphereGeometry({\n                vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,\n                radius : clusterProps.size\n            });\n\n            // Create a geometry instance using the geometry and model matrix created above.\n            var sphereInstance = new Cesium.GeometryInstance({\n                geometry : sphereGeometry,\n                modelMatrix : modelMatrix,\n                attributes : {\n                    color : Cesium.ColorGeometryInstanceAttribute.fromColor(clusterProps.color)\n                }\n            });\n\n            return sphereInstance;\n        }\n\n        buildLabel(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            return {\n                position : Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat, cluster.elev + 20 + (clusterProps.size * 2)),\n                text: cluster.count.toString(),\n                fillColor: Cesium.Color.BLACK,\n                outlineColor: Cesium.Color.RED,\n                font: '30px arial, sans-serif',\n                horizontalOrigin: Cesium.HorizontalOrigin.CENTER//,\n                //eyeOffset: new Cesium.Cartesian3.fromDegrees(0, 0, cluster.elev)\n            };\n        }\n\n        computeClusterAttributes(count: number): any {\n\n            if(count < 10){\n                 return {size: 60000, color: Cesium.Color.fromCssColorString('#4781cd').withAlpha(0.5) };\n            }\n            else if(count >= 10 && count < 250){\n                return {size: 80000, color: Cesium.Color.fromCssColorString('#0fc70e').withAlpha(0.5) };\n            }\n            else {\n                return {size: 90000, color: Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.5) };\n            }\n        }\n    }\n\n    // ng register\n    angular\n        .module('explorer.rockproperties.clusters', [])\n        .factory(\"clusterService\", [\"$http\", \"$rootScope\",\n            ($http: ng.IHttpService, $rootScope: ng.IRootScopeService) =>\n                new rpComponents.clusterService.ClusterService($http, $rootScope)]);\n\n}\n","var rpComponents;!function(e){var t;!function(e){\"use strict\";var t=function(){function e(e,t,r,o,s,i,n,l,u){this.count=e,this.lat=t,this.lon=r,this.elev=o,this.lithologyGroup=s,this.property=i,this.provinceName=n,this.sampleType=l,this.stratigraphicUnitName=u}return e.$inject=[\"count\",\"lat\",\"lon\",\"elev\",\"lithologyGroup\",\"property\",\"provinceName\",\"sampleType\",\"stratigraphicUnitName\"],e}();e.Cluster=t}(t=e.cluster||(e.cluster={}))}(rpComponents||(rpComponents={}));var rpComponents;!function(e){var t;!function(t){\"use strict\";var r=function(){function e(e,t){this.$http=e,this.$rootScope=t}return e.prototype.init=function(e,t){this.viewer=e,this.serviceUrl=t},e.prototype.toggleClusters=function(){this.clustersCollection?this.clustersCollection.show=!this.clustersCollection.show:(this.clustersCollection=new Cesium.PrimitiveCollection,this.viewer.scene.primitives.add(this.clustersCollection),this.addClusters())},e.prototype.getClusters=function(){return this.$http.get(this.serviceUrl+\"clusters\")},e.prototype.addClusters=function(){var e=this,t=[],r=new Cesium.LabelCollection;this.getClusters().then(function(o){if(o.data){for(var s=o.data,i=0;i<s.length;i++)t.push(e.buildSphereInstance(s[i])),r.add(e.buildLabel(s[i]));e.drawClusters(t,r)}else console.log(\"got no clusters\")})},e.prototype.drawClusters=function(e,t){this.clustersCollection.add(new Cesium.Primitive({geometryInstances:e,appearance:new Cesium.PerInstanceColorAppearance({translucent:!0,closed:!0})})),this.clustersCollection.add(t)},e.prototype.buildSphereInstance=function(e){var t=this.computeClusterAttributes(e.count),r=Cesium.Cartesian3.fromDegrees(e.lon,e.lat),o=Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(r),new Cesium.Cartesian3(e.lon,e.lat,e.elev+t.size),new Cesium.Matrix4),s=new Cesium.SphereGeometry({vertexFormat:Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,radius:t.size}),i=new Cesium.GeometryInstance({geometry:s,modelMatrix:o,attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(t.color)}});return i},e.prototype.buildLabel=function(e){var t=this.computeClusterAttributes(e.count);return{position:Cesium.Cartesian3.fromDegrees(e.lon,e.lat,e.elev+20+2*t.size),text:e.count.toString(),fillColor:Cesium.Color.BLACK,outlineColor:Cesium.Color.RED,font:\"30px arial, sans-serif\",horizontalOrigin:Cesium.HorizontalOrigin.CENTER}},e.prototype.computeClusterAttributes=function(e){return 10>e?{size:6e4,color:Cesium.Color.fromCssColorString(\"#4781cd\").withAlpha(.5)}:e>=10&&250>e?{size:8e4,color:Cesium.Color.fromCssColorString(\"#0fc70e\").withAlpha(.5)}:{size:9e4,color:Cesium.Color.fromCssColorString(\"#ff0000\").withAlpha(.5)}},e.$inject=[\"$http\",\"$rootScope\"],e}();t.ClusterService=r,angular.module(\"explorer.rockproperties.clusters\",[]).factory(\"clusterService\",[\"$http\",\"$rootScope\",function(t,r){return new e.clusterService.ClusterService(t,r)}])}(t=e.clusterService||(e.clusterService={}))}(rpComponents||(rpComponents={}));\n//# sourceMappingURL=explorer-rock-properties-components.min.js.map\n"],"sourceRoot":"/source/"}