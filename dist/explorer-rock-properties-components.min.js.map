{"version":3,"sources":["cluster.ts","clusters.ts","explorer-rock-properties-components.min.js","zoom.ts"],"names":["rpComponents","rpComponents.cluster","rpComponents.cluster.Cluster","rpComponents.cluster.Cluster.constructor","rpComponents.clusterService","rpComponents.clusterService.ClusterService","rpComponents.clusterService.ClusterService.constructor","rpComponents.clusterService.ClusterService.init","rpComponents.clusterService.ClusterService.toggleClusters","rpComponents.clusterService.ClusterService.getClusters","rpComponents.clusterService.ClusterService.addClusters","rpComponents.clusterService.ClusterService.drawClusters","rpComponents.clusterService.ClusterService.buildSphereInstance","rpComponents.clusterService.ClusterService.buildLabel","rpComponents.clusterService.ClusterService.computeClusterAttributes","rpComponents.zoom","rpComponents.zoom.ZoomLevelService","rpComponents.zoom.ZoomLevelService.constructor","rpComponents.zoom.ZoomLevelService.setActive"],"mappings":"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","file":"explorer-rock-properties-components.min.js","sourcesContent":["/// <reference path=\"../../typings/tsd.d.ts\" />\n\n/**\n *\n *   Initial shell for single cluster\n *\n */\nmodule rpComponents.cluster {\n\n    'use strict';\n\n    /**\n     *\n     * Each of the properties contains an aggregated data summary, e.g.\n     *\n     * property: {\n     *  \"magnetic susceptibility\": 79.8,\n     *  \"total porosity\": 18.2,\n     *  \"grain mass density\": 2\n     * }\n     *\n     *\n     *\n     */\n    export interface ICluster {\n        count: number,\n        lat: number,\n        lon: number,\n        elev: number,\n        lithologyGroup: {},\n        property: {},\n        provinceName: {},\n        sampleType: {},\n        stratigraphicUnitName: {},\n    }\n\n    export class Cluster implements ICluster{\n\n        static $inject = [\n            \"count\",\n            \"lat\",\n            \"lon\",\n            \"elev\",\n            \"lithologyGroup\",\n            \"property\",\n            \"provinceName\",\n            \"sampleType\",\n            \"stratigraphicUnitName\"\n        ];\n\n        constructor(\n            public count: number,\n            public lat: number,\n            public lon: number,\n            public elev: number,\n            public lithologyGroup: {},\n            public property: {},\n            public provinceName: {},\n            public sampleType: {},\n            public stratigraphicUnitName: {}\n        ) {}\n    }\n\n}","/// <reference path=\"../../typings/tsd.d.ts\" />\n\ndeclare var Cesium: any;\n\nmodule rpComponents.clusterService {\n\n    'use strict';\n\n    export interface IClusterService {\n\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        toggleClusters(): void;\n        getClusters(): [rpComponents.cluster.ICluster];\n        addClusters(): void;\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any;\n        buildLabel(cluster: rpComponents.cluster.ICluster): any;\n        drawClusters(sphereInstances: any, labelCollection: any): void;\n    }\n\n    export class ClusterService implements IClusterService {\n\n        viewer: any;\n        serviceUrl: string;\n        clustersCollection: any;\n\n        static $inject = [\n            \"$http\",\n            \"$rootScope\",\n            \"zoomLevelService\"\n        ];\n\n        constructor(\n            public $http: ng.IHttpService,\n            public $rootScope: ng.IRootScopeService,\n            public zoomLevelService: rpComponents.zoom.IZoomLevelService\n        ) {}\n\n        init(viewer: any, serviceUrl: string): void {\n\n            this.viewer = viewer;\n            this.zoomLevelService.viewer = viewer;\n            this.serviceUrl = serviceUrl;\n        }\n\n        toggleClusters(): void {\n\n            if(this.clustersCollection){\n\n                this.clustersCollection.show = !this.clustersCollection.show;\n                this.zoomLevelService.setActive(this.clustersCollection.show);\n            }\n            else {\n                this.clustersCollection = new Cesium.PrimitiveCollection();\n                this.viewer.scene.primitives.add(this.clustersCollection);\n\n                this.addClusters();\n\n                this.zoomLevelService.setActive(true);\n            }\n        }\n\n        /**\n         *\n         * This will be extended to use extent + zoom on cluster service\n         *\n         * @returns {IHttpPromise<T>}\n         */\n        getClusters(): any {\n            return this.$http.get(this.serviceUrl + 'clusters');\n        }\n\n        /**\n         *\n         * We get a performance benefit when we use fewer primitives/collections to draw multiple static geometries.\n         *\n         */\n        addClusters(): void {\n\n            var sphereInstances: any = [];\n            var labelCollection: any = new Cesium.LabelCollection();\n\n            this.getClusters().then((response: any) => {\n\n                if(response.data){\n\n                    var clusters: [rpComponents.cluster.ICluster] = response.data;\n\n                    for(var i = 0; i < clusters.length; i++){\n                        sphereInstances.push(this.buildSphereInstance(clusters[i]));\n                        labelCollection.add(this.buildLabel(clusters[i]));\n                    }\n\n                    this.drawClusters(sphereInstances, labelCollection);\n                }\n                else {\n                    console.log(\"got no clusters\");\n                }\n            });\n        }\n\n\n        drawClusters(sphereInstances: any, labelCollection: any): void {\n\n            this.clustersCollection.add(new Cesium.Primitive({\n                geometryInstances : sphereInstances,\n                appearance : new Cesium.PerInstanceColorAppearance({\n                    translucent : true,\n                    closed : true\n                })\n            }));\n\n            this.clustersCollection.add(labelCollection);\n        }\n\n        buildSphereInstance(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            // Sphere geometries are initially centered on the origin.\n            // We can use a model matrix to position the sphere on the globe surface.\n            var positionOnEllipsoid = Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat);\n            var modelMatrix = Cesium.Matrix4.multiplyByTranslation(\n                Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid),\n                new Cesium.Cartesian3(cluster.lon, cluster.lat, cluster.elev + clusterProps.size), new Cesium.Matrix4()\n            );\n            // Create a sphere geometry.\n            var sphereGeometry = new Cesium.SphereGeometry({\n                vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,\n                radius : clusterProps.size\n            });\n\n            // Create a geometry instance using the geometry and model matrix created above.\n            var sphereInstance = new Cesium.GeometryInstance({\n                geometry : sphereGeometry,\n                modelMatrix : modelMatrix,\n                attributes : {\n                    color : Cesium.ColorGeometryInstanceAttribute.fromColor(clusterProps.color)\n                }\n            });\n\n            return sphereInstance;\n        }\n\n        buildLabel(cluster: rpComponents.cluster.ICluster): any{\n\n            var clusterProps: {size: number, color: any} = this.computeClusterAttributes(cluster.count);\n\n            return {\n                position : Cesium.Cartesian3.fromDegrees(cluster.lon, cluster.lat, cluster.elev + 20 + (clusterProps.size * 2)),\n                text: cluster.count.toString(),\n                fillColor: Cesium.Color.BLACK,\n                outlineColor: Cesium.Color.RED,\n                font: '30px arial, sans-serif',\n                horizontalOrigin: Cesium.HorizontalOrigin.CENTER//,\n                //eyeOffset: new Cesium.Cartesian3.fromDegrees(0, 0, cluster.elev)\n            };\n        }\n\n        computeClusterAttributes(count: number): any {\n\n            if(count < 10){\n                 return {size: 60000, color: Cesium.Color.fromCssColorString('#4781cd').withAlpha(0.5) };\n            }\n            else if(count >= 10 && count < 250){\n                return {size: 80000, color: Cesium.Color.fromCssColorString('#0fc70e').withAlpha(0.5) };\n            }\n            else {\n                return {size: 90000, color: Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.5) };\n            }\n        }\n    }\n\n    // ng register\n    angular\n        .module('explorer.rockproperties.clusters', [])\n        .factory(\"clusterService\", [\"$http\", \"$rootScope\", \"zoomLevelService\",\n            ($http: ng.IHttpService, $rootScope: ng.IRootScopeService, zoomLevelService: rpComponents.zoom.IZoomLevelService) =>\n                new rpComponents.clusterService.ClusterService($http, $rootScope, zoomLevelService)]);\n\n}\n","var rpComponents;!function(e){var t;!function(e){\"use strict\";var t=function(){function e(e,t,o,r,i,s,n,l,c){this.count=e,this.lat=t,this.lon=o,this.elev=r,this.lithologyGroup=i,this.property=s,this.provinceName=n,this.sampleType=l,this.stratigraphicUnitName=c}return e.$inject=[\"count\",\"lat\",\"lon\",\"elev\",\"lithologyGroup\",\"property\",\"provinceName\",\"sampleType\",\"stratigraphicUnitName\"],e}();e.Cluster=t}(t=e.cluster||(e.cluster={}))}(rpComponents||(rpComponents={}));var rpComponents;!function(e){var t;!function(t){\"use strict\";var o=function(){function e(e,t,o){this.$http=e,this.$rootScope=t,this.zoomLevelService=o}return e.prototype.init=function(e,t){this.viewer=e,this.zoomLevelService.viewer=e,this.serviceUrl=t},e.prototype.toggleClusters=function(){this.clustersCollection?(this.clustersCollection.show=!this.clustersCollection.show,this.zoomLevelService.setActive(this.clustersCollection.show)):(this.clustersCollection=new Cesium.PrimitiveCollection,this.viewer.scene.primitives.add(this.clustersCollection),this.addClusters(),this.zoomLevelService.setActive(!0))},e.prototype.getClusters=function(){return this.$http.get(this.serviceUrl+\"clusters\")},e.prototype.addClusters=function(){var e=this,t=[],o=new Cesium.LabelCollection;this.getClusters().then(function(r){if(r.data){for(var i=r.data,s=0;s<i.length;s++)t.push(e.buildSphereInstance(i[s])),o.add(e.buildLabel(i[s]));e.drawClusters(t,o)}else console.log(\"got no clusters\")})},e.prototype.drawClusters=function(e,t){this.clustersCollection.add(new Cesium.Primitive({geometryInstances:e,appearance:new Cesium.PerInstanceColorAppearance({translucent:!0,closed:!0})})),this.clustersCollection.add(t)},e.prototype.buildSphereInstance=function(e){var t=this.computeClusterAttributes(e.count),o=Cesium.Cartesian3.fromDegrees(e.lon,e.lat),r=Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(o),new Cesium.Cartesian3(e.lon,e.lat,e.elev+t.size),new Cesium.Matrix4),i=new Cesium.SphereGeometry({vertexFormat:Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,radius:t.size}),s=new Cesium.GeometryInstance({geometry:i,modelMatrix:r,attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(t.color)}});return s},e.prototype.buildLabel=function(e){var t=this.computeClusterAttributes(e.count);return{position:Cesium.Cartesian3.fromDegrees(e.lon,e.lat,e.elev+20+2*t.size),text:e.count.toString(),fillColor:Cesium.Color.BLACK,outlineColor:Cesium.Color.RED,font:\"30px arial, sans-serif\",horizontalOrigin:Cesium.HorizontalOrigin.CENTER}},e.prototype.computeClusterAttributes=function(e){return 10>e?{size:6e4,color:Cesium.Color.fromCssColorString(\"#4781cd\").withAlpha(.5)}:e>=10&&250>e?{size:8e4,color:Cesium.Color.fromCssColorString(\"#0fc70e\").withAlpha(.5)}:{size:9e4,color:Cesium.Color.fromCssColorString(\"#ff0000\").withAlpha(.5)}},e.$inject=[\"$http\",\"$rootScope\",\"zoomLevelService\"],e}();t.ClusterService=o,angular.module(\"explorer.rockproperties.clusters\",[]).factory(\"clusterService\",[\"$http\",\"$rootScope\",\"zoomLevelService\",function(t,o,r){return new e.clusterService.ClusterService(t,o,r)}])}(t=e.clusterService||(e.clusterService={}))}(rpComponents||(rpComponents={}));var rpComponents;!function(e){var t;!function(t){\"use strict\";var o=function(){function e(e){var t=this;this.$rootScope=e,this.moveEndHandler=function(){console.log(Cesium.Ellipsoid.WGS84.cartesianToCartographic(t.viewer.camera.position).height)}}return e.prototype.setActive=function(e){e?this.viewer.camera.moveEnd.addEventListener(this.moveEndHandler):this.viewer.camera.moveEnd.removeEventListener(this.moveEndHandler)},e.$inject=[\"$rootScope\"],e}();t.ZoomLevelService=o,angular.module(\"explorer.rockproperties.zoom\",[]).factory(\"zoomLevelService\",[\"$rootScope\",function(t){return new e.zoom.ZoomLevelService(t)}])}(t=e.zoom||(e.zoom={}))}(rpComponents||(rpComponents={}));\n//# sourceMappingURL=explorer-rock-properties-components.min.js.map\n","/// <reference path=\"../../typings/tsd.d.ts\" />\n\ndeclare var Cesium: any;\n\n/**\n *\n * Handles the arbitrary 'zoom' levels/ranges that we will display different cluster granularities.\n *\n *\n */\nmodule rpComponents.zoom {\n\n    'use strict';\n\n    export interface IZoomLevelService {\n        viewer: any;\n        setActive(active:boolean): void;\n        moveEndHandler(): void;\n    }\n\n    export class ZoomLevelService implements IZoomLevelService {\n\n        viewer:any;\n\n        static $inject = [\n            \"$rootScope\"\n        ];\n\n        constructor(public $rootScope:ng.IRootScopeService) {}\n\n        /**\n         * TS syntax to so we don't lose this scope for event listener\n         * https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript\n         */\n        public moveEndHandler = () => {\n            console.log(Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.viewer.camera.position).height);\n        };\n\n        public setActive(active:boolean) {\n\n            if(active) {\n                this.viewer.camera.moveEnd.addEventListener(this.moveEndHandler);\n            }\n            else {\n                this.viewer.camera.moveEnd.removeEventListener(this.moveEndHandler);\n            }\n\n        }\n\n\n    }\n\n    // ng register\n    angular\n        .module('explorer.rockproperties.zoom', [])\n        .factory(\"zoomLevelService\", [\"$rootScope\",\n            ($rootScope:ng.IRootScopeService) => new rpComponents.zoom.ZoomLevelService($rootScope)]);\n\n}\n"],"sourceRoot":"/source/"}